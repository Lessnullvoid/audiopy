# üéπ Interactive Sound Synthesis Learning Tool

![Synthesizer Interface](https://github.com/Lessnullvoid/audiopy/blob/main/01.synth/synth.png)

An educational tool designed to help beginners understand the fundamentals of sound synthesis through interactive experimentation. It provides a visual and hands-on approach to learning about waveforms, filters, and audio effects.

## üéº What is Sound Synthesis?

Sound synthesis is the process of generating sound electronically. At its core, synthesis involves:

1. **Oscillators**: Electronic circuits or digital algorithms that generate repeating waveforms
2. **Waveforms**: Different shapes of sound waves that produce different timbres:
   - üåä Sine wave: Pure tone, like a whistle
   - ‚¨ú Square wave: Hollow, rich sound like old video games
   - üìê Sawtooth: Bright, buzzy sound common in electronic music
   - üî∫ Triangle: Soft, mellow sound between sine and square
   - ‚ö° Pulse: Nasal, thin sound with variable width
   - üå´Ô∏è Noise: Random frequencies, useful for percussion and effects
   - üîÑ FM: Frequency modulation for complex, evolving sounds
   - üéµ Harmonics: Multiple sine waves combined for rich tones
3. **Filters**: Shape the tone by removing certain frequencies

## üéõÔ∏è Program Features

### 1. Interactive Grid Interface
- X-axis: Controls frequency (pitch)
- Y-axis: Controls filter cutoff in filter mode
- Click and drag to explore different sounds
- Real-time waveform visualization

### 2. Filters
Two types of filters that shape the sound:
- **Low-Pass (LP)**: Removes high frequencies, making sound darker
- **High-Pass (HP)**: Removes low frequencies, making sound thinner

### 3. Delay Effect
A time-based effect that creates echoes:
- Adjustable delay time
- Feedback control for multiple echoes
- Wet/dry mix for effect intensity

## üéÆ Quick Start Guide

1. Install requirements:
```bash
pip install pygame numpy sounddevice scipy
```

2. Run the program:
```bash
python main.py
```

3. Start experimenting:
   - Press number keys (1-8) to change waveforms
   - Move mouse to control frequency
   - Press 'B' for filter mode
   - Press 'E' to enable effects

## ‚å®Ô∏è Controls Reference

### Basic Controls
| Key/Action | Function |
|------------|----------|
| Space/Click | Start/Stop sound |
| Mouse Movement | Control frequency and filter |
| A | Frequency control mode |
| B | Frequency + filter control mode |
| E | Enable/Disable effects |
| ESC | Quit program |

### Waveform Selection
| Key | Waveform | Description |
|-----|----------|-------------|
| 1 | Sine | Pure tone |
| 2 | Square | Hollow, rich sound |
| 3 | Sawtooth | Bright, buzzy sound |
| 4 | Triangle | Soft, mellow sound |
| 5 | Pulse | Nasal, thin sound |
| 6 | Noise | Random frequencies |
| 7 | FM | Frequency modulation |
| 8 | Harmonics | Rich, layered sound |

## üîß Technical Implementation

### Core Components
- **Python**: Core programming language
- **Pygame**: Graphics and user interface
- **NumPy**: Efficient waveform generation
- **SoundDevice**: Real-time audio output

### Key Features
1. Real-time waveform generation
2. Digital signal processing for filters
3. Circular buffer for delay effects
4. Anti-aliased waveform visualization

## üìö Educational Value

This tool helps understand:
- ‚ú® Relationship between frequency and pitch
- üåä How different waveforms create different timbres
- üéõÔ∏è Effect of filters on sound character
- üîÑ Basic audio effects and signal processing
- üéπ Real-time audio synthesis concepts

## üíª System Requirements
- Python 3.7+
- Working audio output device
- Dependencies:
  - Pygame
  - NumPy
  - SoundDevice
  - SciPy

## ü§ù Contributing

We welcome contributions! Here's how you can help:
- üéµ Add new waveforms
- üéõÔ∏è Implement additional effects
- üìä Improve visualizations
- üìö Add more educational features

## üìù License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- Thanks to the Python audio community
- Inspired by classic analog synthesizers
- Built with love for music education

# Python Synthesizer Implementation

A real-time software synthesizer implemented in Python using Pygame for the interface and NumPy for audio processing.

## Technical Implementation

### Waveform Generation and Oscillators

The synthesizer implements several waveform types through mathematical algorithms:

1. **Sine Wave**
   - Implementation: `np.sin(2 * np.pi * frequency * t)`
   - Pure sinusoidal oscillation using NumPy's sin function
   - Produces the cleanest, purest tone with no harmonics

2. **Square Wave**
   - Implementation: `np.sign(np.sin(2 * np.pi * frequency * t))`
   - Created using the sign function on a sine wave
   - Rich in odd harmonics, producing a hollow, bright sound

3. **Sawtooth Wave**
   - Implementation: `2 * (t * frequency - np.floor(0.5 + t * frequency))`
   - Generated by accumulating phase and wrapping
   - Contains both odd and even harmonics, creating a bright, harsh tone

4. **Triangle Wave**
   - Implementation: `2 * abs(2 * (t * frequency - np.floor(0.5 + t * frequency))) - 1`
   - Modified sawtooth wave using absolute value
   - Softer than sawtooth due to reduced higher harmonics

5. **Pulse Wave**
   - Implementation: Variable duty cycle square wave
   - Uses comparison with duty cycle threshold
   - Allows for pulse width modulation (PWM)

6. **Noise Oscillator**
   - Implementation: `np.random.uniform(-1, 1, size=buffer_size)`
   - Generates white noise using uniform random distribution
   - Useful for percussion and special effects

7. **FM (Frequency Modulation)**
   - Implementation: Carrier wave modulated by modulator wave
   - `carrier_freq * (1 + mod_index * np.sin(2 * np.pi * mod_freq * t))`
   - Creates complex timbres through frequency modulation

8. **Harmonics**
   - Implementation: Sum of multiple sine waves at harmonic frequencies
   - `Œ£(amplitude[n] * sin(2œÄ * n * fundamental * t))`
   - Creates rich, organic tones through additive synthesis

### Filter Implementation

The synthesizer implements one-pole filters (first-order IIR filters):

1. **Low-Pass Filter**
   ```python
   y[n] = Œ± * x[n] + (1-Œ±) * y[n-1]
   where Œ± = 2œÄ * cutoff / sample_rate
   ```
   - Attenuates frequencies above cutoff point
   - Smooth 6dB/octave rolloff
   - Real-time coefficient updates based on mouse position

2. **High-Pass Filter**
   ```python
   y[n] = Œ± * (y[n-1] + x[n] - x[n-1])
   where Œ± = 1 / (1 + 2œÄ * cutoff / sample_rate)
   ```
   - Attenuates frequencies below cutoff point
   - Complementary to low-pass response
   - Dynamic cutoff frequency control

### Delay Effect System

The delay effect uses a circular buffer implementation:
- Configurable delay time (up to 1000ms)
- Feedback control (0-95%)
- Wet/dry mix control
- Sample-accurate timing using buffer manipulation

### Real-time Audio Processing

The audio system uses:
- Buffer size: 1024 samples
- Sample rate: 44100 Hz
- 32-bit floating point audio processing
- Callback-based audio output for minimal latency

## File Structure

### `main.py`
- Main application entry point
- Pygame interface implementation
- Event handling and user input processing
- Real-time visualization system
- Waveform selector and parameter controls

### `synth.py`
- Core synthesis engine
- Oscillator implementations
- Filter processing
- Audio callback system
- Parameter management
- Effect processing (delay)

### `oscillator.py`
- Base oscillator class
- Individual waveform generator classes
- Phase accumulation system
- Amplitude control

### `filter.py`
- Filter implementations (LP/HP)
- Coefficient calculation
- Signal processing algorithms

## Control System

### Mouse Control
- X-axis: Frequency control (20Hz - 2000Hz, logarithmic)
- Y-axis: 
  - Mode A: Amplitude control
  - Mode B: Filter cutoff frequency

### Keyboard Controls
- Space: Toggle sound on/off
- A/B: Switch between amplitude and filter modes
- L/H: Switch between low-pass and high-pass filters
- 1-8: Quick waveform selection
- E: Toggle effects
- D: Enter delay control mode
- Arrow keys: Delay parameter control

## Signal Flow

1. Oscillator generates raw waveform
2. Signal passes through filter (if enabled)
3. Processed through effects (if enabled)
4. Final output sent to audio device
5. Visualization updated with current sample

## Performance Considerations

- NumPy vectorized operations for efficient waveform generation
- Pre-calculated lookup tables for complex waveforms
- Optimized buffer sizes for low latency
- Efficient parameter interpolation for smooth changes
- Minimal garbage collection impact through buffer reuse

## Technical Requirements

- Python 3.8+
- Pygame 2.0+
- NumPy
- PyAudio or SDL audio backend
- Minimum 2.0 GHz CPU recommended
- Low-latency audio device 